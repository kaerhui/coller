// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: player.proto

#ifndef PROTOBUF_INCLUDED_player_2eproto
#define PROTOBUF_INCLUDED_player_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_player_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_player_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_player_2eproto();
namespace com {
namespace oppo {
namespace ohacker {
namespace player {
class Chess;
class ChessDefaultTypeInternal;
extern ChessDefaultTypeInternal _Chess_default_instance_;
class ChessPosition;
class ChessPositionDefaultTypeInternal;
extern ChessPositionDefaultTypeInternal _ChessPosition_default_instance_;
class InitRequest;
class InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
class InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class MoveRequest;
class MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class MoveResponse;
class MoveResponseDefaultTypeInternal;
extern MoveResponseDefaultTypeInternal _MoveResponse_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
}  // namespace player
}  // namespace ohacker
}  // namespace oppo
}  // namespace com
namespace google {
namespace protobuf {
template<> ::com::oppo::ohacker::player::Chess* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::Chess>(Arena*);
template<> ::com::oppo::ohacker::player::ChessPosition* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::ChessPosition>(Arena*);
template<> ::com::oppo::ohacker::player::InitRequest* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::InitRequest>(Arena*);
template<> ::com::oppo::ohacker::player::InitResponse* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::InitResponse>(Arena*);
template<> ::com::oppo::ohacker::player::MoveRequest* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::MoveRequest>(Arena*);
template<> ::com::oppo::ohacker::player::MoveResponse* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::MoveResponse>(Arena*);
template<> ::com::oppo::ohacker::player::Position* Arena::CreateMaybeMessage<::com::oppo::ohacker::player::Position>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace com {
namespace oppo {
namespace ohacker {
namespace player {

// ===================================================================

class InitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.InitRequest) */ {
 public:
  InitRequest();
  virtual ~InitRequest();

  InitRequest(const InitRequest& from);

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InitRequest* other);
  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitRequest* New() const final {
    return CreateMaybeMessage<InitRequest>(nullptr);
  }

  InitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitRequest& from);
  void MergeFrom(const InitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isFirstHand = 1;
  void clear_isfirsthand();
  static const int kIsFirstHandFieldNumber = 1;
  bool isfirsthand() const;
  void set_isfirsthand(bool value);

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.InitRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool isfirsthand_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class Chess final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.Chess) */ {
 public:
  Chess();
  virtual ~Chess();

  Chess(const Chess& from);

  inline Chess& operator=(const Chess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chess(Chess&& from) noexcept
    : Chess() {
    *this = ::std::move(from);
  }

  inline Chess& operator=(Chess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Chess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chess* internal_default_instance() {
    return reinterpret_cast<const Chess*>(
               &_Chess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Chess* other);
  friend void swap(Chess& a, Chess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chess* New() const final {
    return CreateMaybeMessage<Chess>(nullptr);
  }

  Chess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chess& from);
  void MergeFrom(const Chess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 chessId = 1;
  void clear_chessid();
  static const int kChessIdFieldNumber = 1;
  ::google::protobuf::int32 chessid() const;
  void set_chessid(::google::protobuf::int32 value);

  // int32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.Chess)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 chessid_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.Position)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class ChessPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.ChessPosition) */ {
 public:
  ChessPosition();
  virtual ~ChessPosition();

  ChessPosition(const ChessPosition& from);

  inline ChessPosition& operator=(const ChessPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChessPosition(ChessPosition&& from) noexcept
    : ChessPosition() {
    *this = ::std::move(from);
  }

  inline ChessPosition& operator=(ChessPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChessPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChessPosition* internal_default_instance() {
    return reinterpret_cast<const ChessPosition*>(
               &_ChessPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ChessPosition* other);
  friend void swap(ChessPosition& a, ChessPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChessPosition* New() const final {
    return CreateMaybeMessage<ChessPosition>(nullptr);
  }

  ChessPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChessPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChessPosition& from);
  void MergeFrom(const ChessPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChessPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .com.oppo.ohacker.player.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::com::oppo::ohacker::player::Position& position() const;
  ::com::oppo::ohacker::player::Position* release_position();
  ::com::oppo::ohacker::player::Position* mutable_position();
  void set_allocated_position(::com::oppo::ohacker::player::Position* position);

  // .com.oppo.ohacker.player.Chess chess = 2;
  bool has_chess() const;
  void clear_chess();
  static const int kChessFieldNumber = 2;
  const ::com::oppo::ohacker::player::Chess& chess() const;
  ::com::oppo::ohacker::player::Chess* release_chess();
  ::com::oppo::ohacker::player::Chess* mutable_chess();
  void set_allocated_chess(::com::oppo::ohacker::player::Chess* chess);

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.ChessPosition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::com::oppo::ohacker::player::Position* position_;
  ::com::oppo::ohacker::player::Chess* chess_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class MoveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.MoveRequest) */ {
 public:
  MoveRequest();
  virtual ~MoveRequest();

  MoveRequest(const MoveRequest& from);

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MoveRequest* other);
  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveRequest* New() const final {
    return CreateMaybeMessage<MoveRequest>(nullptr);
  }

  MoveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoveRequest& from);
  void MergeFrom(const MoveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.oppo.ohacker.player.ChessPosition chessPositions = 1;
  int chesspositions_size() const;
  void clear_chesspositions();
  static const int kChessPositionsFieldNumber = 1;
  ::com::oppo::ohacker::player::ChessPosition* mutable_chesspositions(int index);
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >*
      mutable_chesspositions();
  const ::com::oppo::ohacker::player::ChessPosition& chesspositions(int index) const;
  ::com::oppo::ohacker::player::ChessPosition* add_chesspositions();
  const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >&
      chesspositions() const;

  // bool isFirstHand = 2;
  void clear_isfirsthand();
  static const int kIsFirstHandFieldNumber = 2;
  bool isfirsthand() const;
  void set_isfirsthand(bool value);

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.MoveRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition > chesspositions_;
  bool isfirsthand_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class InitResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.InitResponse) */ {
 public:
  InitResponse();
  virtual ~InitResponse();

  InitResponse(const InitResponse& from);

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(InitResponse* other);
  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitResponse* New() const final {
    return CreateMaybeMessage<InitResponse>(nullptr);
  }

  InitResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitResponse& from);
  void MergeFrom(const InitResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.oppo.ohacker.player.ChessPosition chessPosition = 1;
  int chessposition_size() const;
  void clear_chessposition();
  static const int kChessPositionFieldNumber = 1;
  ::com::oppo::ohacker::player::ChessPosition* mutable_chessposition(int index);
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >*
      mutable_chessposition();
  const ::com::oppo::ohacker::player::ChessPosition& chessposition(int index) const;
  ::com::oppo::ohacker::player::ChessPosition* add_chessposition();
  const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >&
      chessposition() const;

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.InitResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition > chessposition_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class MoveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.oppo.ohacker.player.MoveResponse) */ {
 public:
  MoveResponse();
  virtual ~MoveResponse();

  MoveResponse(const MoveResponse& from);

  inline MoveResponse& operator=(const MoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoveResponse(MoveResponse&& from) noexcept
    : MoveResponse() {
    *this = ::std::move(from);
  }

  inline MoveResponse& operator=(MoveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveResponse* internal_default_instance() {
    return reinterpret_cast<const MoveResponse*>(
               &_MoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MoveResponse* other);
  friend void swap(MoveResponse& a, MoveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveResponse* New() const final {
    return CreateMaybeMessage<MoveResponse>(nullptr);
  }

  MoveResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoveResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoveResponse& from);
  void MergeFrom(const MoveResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.oppo.ohacker.player.Position position = 1;
  int position_size() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::com::oppo::ohacker::player::Position* mutable_position(int index);
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::Position >*
      mutable_position();
  const ::com::oppo::ohacker::player::Position& position(int index) const;
  ::com::oppo::ohacker::player::Position* add_position();
  const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::Position >&
      position() const;

  // @@protoc_insertion_point(class_scope:com.oppo.ohacker.player.MoveResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::Position > position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_player_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InitRequest

// bool isFirstHand = 1;
inline void InitRequest::clear_isfirsthand() {
  isfirsthand_ = false;
}
inline bool InitRequest::isfirsthand() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.InitRequest.isFirstHand)
  return isfirsthand_;
}
inline void InitRequest::set_isfirsthand(bool value) {
  
  isfirsthand_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.InitRequest.isFirstHand)
}

// -------------------------------------------------------------------

// Chess

// int32 chessId = 1;
inline void Chess::clear_chessid() {
  chessid_ = 0;
}
inline ::google::protobuf::int32 Chess::chessid() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.Chess.chessId)
  return chessid_;
}
inline void Chess::set_chessid(::google::protobuf::int32 value) {
  
  chessid_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.Chess.chessId)
}

// int32 value = 2;
inline void Chess::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 Chess::value() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.Chess.value)
  return value_;
}
inline void Chess::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.Chess.value)
}

// -------------------------------------------------------------------

// Position

// int32 x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Position::x() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.Position.x)
  return x_;
}
inline void Position::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.Position.x)
}

// int32 y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Position::y() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.Position.y)
  return y_;
}
inline void Position::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.Position.y)
}

// -------------------------------------------------------------------

// ChessPosition

// .com.oppo.ohacker.player.Position position = 1;
inline bool ChessPosition::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void ChessPosition::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::com::oppo::ohacker::player::Position& ChessPosition::position() const {
  const ::com::oppo::ohacker::player::Position* p = position_;
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.ChessPosition.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::oppo::ohacker::player::Position*>(
      &::com::oppo::ohacker::player::_Position_default_instance_);
}
inline ::com::oppo::ohacker::player::Position* ChessPosition::release_position() {
  // @@protoc_insertion_point(field_release:com.oppo.ohacker.player.ChessPosition.position)
  
  ::com::oppo::ohacker::player::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::com::oppo::ohacker::player::Position* ChessPosition::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::oppo::ohacker::player::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.oppo.ohacker.player.ChessPosition.position)
  return position_;
}
inline void ChessPosition::set_allocated_position(::com::oppo::ohacker::player::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:com.oppo.ohacker.player.ChessPosition.position)
}

// .com.oppo.ohacker.player.Chess chess = 2;
inline bool ChessPosition::has_chess() const {
  return this != internal_default_instance() && chess_ != nullptr;
}
inline void ChessPosition::clear_chess() {
  if (GetArenaNoVirtual() == nullptr && chess_ != nullptr) {
    delete chess_;
  }
  chess_ = nullptr;
}
inline const ::com::oppo::ohacker::player::Chess& ChessPosition::chess() const {
  const ::com::oppo::ohacker::player::Chess* p = chess_;
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.ChessPosition.chess)
  return p != nullptr ? *p : *reinterpret_cast<const ::com::oppo::ohacker::player::Chess*>(
      &::com::oppo::ohacker::player::_Chess_default_instance_);
}
inline ::com::oppo::ohacker::player::Chess* ChessPosition::release_chess() {
  // @@protoc_insertion_point(field_release:com.oppo.ohacker.player.ChessPosition.chess)
  
  ::com::oppo::ohacker::player::Chess* temp = chess_;
  chess_ = nullptr;
  return temp;
}
inline ::com::oppo::ohacker::player::Chess* ChessPosition::mutable_chess() {
  
  if (chess_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::oppo::ohacker::player::Chess>(GetArenaNoVirtual());
    chess_ = p;
  }
  // @@protoc_insertion_point(field_mutable:com.oppo.ohacker.player.ChessPosition.chess)
  return chess_;
}
inline void ChessPosition::set_allocated_chess(::com::oppo::ohacker::player::Chess* chess) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chess_;
  }
  if (chess) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chess = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chess, submessage_arena);
    }
    
  } else {
    
  }
  chess_ = chess;
  // @@protoc_insertion_point(field_set_allocated:com.oppo.ohacker.player.ChessPosition.chess)
}

// -------------------------------------------------------------------

// MoveRequest

// repeated .com.oppo.ohacker.player.ChessPosition chessPositions = 1;
inline int MoveRequest::chesspositions_size() const {
  return chesspositions_.size();
}
inline void MoveRequest::clear_chesspositions() {
  chesspositions_.Clear();
}
inline ::com::oppo::ohacker::player::ChessPosition* MoveRequest::mutable_chesspositions(int index) {
  // @@protoc_insertion_point(field_mutable:com.oppo.ohacker.player.MoveRequest.chessPositions)
  return chesspositions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >*
MoveRequest::mutable_chesspositions() {
  // @@protoc_insertion_point(field_mutable_list:com.oppo.ohacker.player.MoveRequest.chessPositions)
  return &chesspositions_;
}
inline const ::com::oppo::ohacker::player::ChessPosition& MoveRequest::chesspositions(int index) const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.MoveRequest.chessPositions)
  return chesspositions_.Get(index);
}
inline ::com::oppo::ohacker::player::ChessPosition* MoveRequest::add_chesspositions() {
  // @@protoc_insertion_point(field_add:com.oppo.ohacker.player.MoveRequest.chessPositions)
  return chesspositions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >&
MoveRequest::chesspositions() const {
  // @@protoc_insertion_point(field_list:com.oppo.ohacker.player.MoveRequest.chessPositions)
  return chesspositions_;
}

// bool isFirstHand = 2;
inline void MoveRequest::clear_isfirsthand() {
  isfirsthand_ = false;
}
inline bool MoveRequest::isfirsthand() const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.MoveRequest.isFirstHand)
  return isfirsthand_;
}
inline void MoveRequest::set_isfirsthand(bool value) {
  
  isfirsthand_ = value;
  // @@protoc_insertion_point(field_set:com.oppo.ohacker.player.MoveRequest.isFirstHand)
}

// -------------------------------------------------------------------

// InitResponse

// repeated .com.oppo.ohacker.player.ChessPosition chessPosition = 1;
inline int InitResponse::chessposition_size() const {
  return chessposition_.size();
}
inline void InitResponse::clear_chessposition() {
  chessposition_.Clear();
}
inline ::com::oppo::ohacker::player::ChessPosition* InitResponse::mutable_chessposition(int index) {
  // @@protoc_insertion_point(field_mutable:com.oppo.ohacker.player.InitResponse.chessPosition)
  return chessposition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >*
InitResponse::mutable_chessposition() {
  // @@protoc_insertion_point(field_mutable_list:com.oppo.ohacker.player.InitResponse.chessPosition)
  return &chessposition_;
}
inline const ::com::oppo::ohacker::player::ChessPosition& InitResponse::chessposition(int index) const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.InitResponse.chessPosition)
  return chessposition_.Get(index);
}
inline ::com::oppo::ohacker::player::ChessPosition* InitResponse::add_chessposition() {
  // @@protoc_insertion_point(field_add:com.oppo.ohacker.player.InitResponse.chessPosition)
  return chessposition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::ChessPosition >&
InitResponse::chessposition() const {
  // @@protoc_insertion_point(field_list:com.oppo.ohacker.player.InitResponse.chessPosition)
  return chessposition_;
}

// -------------------------------------------------------------------

// MoveResponse

// repeated .com.oppo.ohacker.player.Position position = 1;
inline int MoveResponse::position_size() const {
  return position_.size();
}
inline void MoveResponse::clear_position() {
  position_.Clear();
}
inline ::com::oppo::ohacker::player::Position* MoveResponse::mutable_position(int index) {
  // @@protoc_insertion_point(field_mutable:com.oppo.ohacker.player.MoveResponse.position)
  return position_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::Position >*
MoveResponse::mutable_position() {
  // @@protoc_insertion_point(field_mutable_list:com.oppo.ohacker.player.MoveResponse.position)
  return &position_;
}
inline const ::com::oppo::ohacker::player::Position& MoveResponse::position(int index) const {
  // @@protoc_insertion_point(field_get:com.oppo.ohacker.player.MoveResponse.position)
  return position_.Get(index);
}
inline ::com::oppo::ohacker::player::Position* MoveResponse::add_position() {
  // @@protoc_insertion_point(field_add:com.oppo.ohacker.player.MoveResponse.position)
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::oppo::ohacker::player::Position >&
MoveResponse::position() const {
  // @@protoc_insertion_point(field_list:com.oppo.ohacker.player.MoveResponse.position)
  return position_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace player
}  // namespace ohacker
}  // namespace oppo
}  // namespace com

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_player_2eproto
